# -*- coding: utf-8 -*-
"""Stock-Price-Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1thh3y3PJgnVB0IyonOuubXfSJECu9mqh

#Stock Price Prediction Using Stacked LSTM
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_theme(context='notebook', style='darkgrid', palette='pastel', font='sans-serif', font_scale=1, color_codes=True, rc=None)

"""## Step 1: Data Preprocessing

**Explanation:**
In this step, we prepare our data for training and testing the LSTM model. This involves the following sub-steps:

1. **Data Collection:** Obtain historical stock price data. You can use libraries like pandas or APIs to fetch this data.

2. **Data Cleaning:** Check for missing values, outliers, and inconsistencies in the data. Handle them by either removing or imputing the data.

3. **Feature Selection/Engineering:** Select relevant features for prediction or create new features that might be helpful. For stock price prediction, common features include Open Price, Close Price, High Price, Low Price, Volume, etc.

4. **Data Normalization/Scaling:** Scale the data to a common range, often between 0 and 1, to help the neural network converge faster.

###Gathering the data
"""

stock_sybol = "AAPL"
start_date = "2011-01-01"
end_date = "2023-01-01"

stocks = yf.download(stock_sybol,start_date,end_date)

"""###Analyzing data

"""

stocks.head()

stocks.tail()

stocks.isnull().sum()

stocks.index

plt.plot(stocks.index, stocks["Close"])

stocks.shape

stocks.describe()

"""###Function to create scaled sequences from time series data"""

def create_scaled_sequences(data, sequence_length):
    # Scale the data to a range between 0 and 1
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(data.values.reshape(-1, 1))

    X, y = [], []
    for i in range(len(scaled_data) - sequence_length):
        X.append(scaled_data[i:i + sequence_length])
        y.append(scaled_data[i + sequence_length])
    return np.array(X), np.array(y), scaler

"""## Step 2: Data Splitting

**Explanation:**
In this step, we divide our data into training and testing sets. This is crucial to evaluate the model's performance. The training set is used to train the model, while the testing set is used to assess how well the model generalizes to unseen data.

1. **Time Series Split:** Since stock price data has a temporal aspect, we typically use a time-based split. This means we use data from earlier time periods for training and more recent data for testing.

###We consider 80% dataset as the training data and 20% as test data.
"""

len(stocks)

train_percentage = 0.80
split_index = int(len(stocks) * train_percentage)

train_data = stocks[0 : split_index]
test_data = stocks[split_index : len(stocks)]

train_data.shape , test_data.shape

train_data

test_data

"""## Step 3: Sequence Generation

**Explanation:**
In this step, we create sequences of data that will be fed into the LSTM model. LSTMs are well-suited for sequence data, and for stock price prediction, we can use a sliding window approach to create input-output pairs.

1. **Define Sequence Length:** Decide on the sequence length, which represents the number of previous time steps the model will use to make predictions. For example, if you choose a sequence length of 10, the model will use the past 10 days' stock prices to predict the price for the 11th day.

2. **Create Sequences:** Create input-output pairs (X and y) by sliding the sequence window through the training data. X contains the historical prices, and y contains the target price to be predicted.

### Performing Time Series Split
"""

sequence_length = 50

"""Retrieving the closing price and assigning it as the evaluation feature.

Both the Training and Testing datasets have their individual scalers.


"""

X_train, y_train, scaler_train = create_scaled_sequences(train_data['Close'], sequence_length)

X_train.shape, y_train.shape

X_test, y_test, scaler_test = create_scaled_sequences(test_data['Close'], sequence_length)

X_test.shape, y_test.shape

"""## Step 4: Model Building

**Explanation:**
In this step, we'll define and build the LSTM model for stock price prediction. LSTMs are a type of recurrent neural network (RNN) that are well-suited for sequence prediction tasks.

1. **Import Libraries:** Import the necessary libraries for building the LSTM model. Common libraries include TensorFlow or PyTorch for deep learning.

2. **Define the LSTM Model:** Create the architecture of the LSTM model. You'll specify the number of LSTM units (neurons), activation functions, and any additional layers. Common choices include adding Dense layers for regression tasks.

3. **Compile the Model:** Configure the loss function, optimizer, and evaluation metrics. For stock price prediction, Mean Squared Error (MSE) is often used as the loss function.

4. **Train the Model:** Feed the training data (X_train and y_train) into the model and train it. This involves iterating through the data for multiple epochs (iterations).

"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Define the Stacked LSTM model architecture
model = Sequential()
model.add(LSTM(50,return_sequences=True,input_shape=(50,1)))
model.add(LSTM(50,return_sequences=True))
model.add(LSTM(50))
model.add(Dense(1))
model.compile(loss='mean_squared_error',optimizer='adam')

model.fit(X_train, y_train, epochs=100, batch_size=32)

"""## Step 5: Model Evaluation

**Explanation:**
In this step, we'll evaluate the LSTM model's performance using the testing data. This will help us understand how well the model generalizes to unseen data and whether it can effectively predict stock prices.

1. **Make Predictions:** Use the trained LSTM model to make predictions on the testing data (X_test).

2. **Inverse Scaling:** Since we scaled the data in Step 1, we need to inverse transform the predicted values to get them back into the original scale.

3. **Evaluate the Model:** Calculate evaluation metrics to assess the model's performance. Common metrics for regression tasks like stock price prediction include Mean Squared Error (MSE), Root Mean Squared Error (RMSE), and Mean Absolute Error (MAE).

"""

# Step 5: Model Evaluation
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
# Make predictions on the testing data
y_test_predictions = model.predict(X_test)

# Inverse scale the predictions to the original data range
y_test_predictions = scaler_test.inverse_transform(y_test_predictions)
y_test_actual = scaler_test.inverse_transform(y_test.reshape(-1, 1))

# Calculate evaluation metrics
rmse = np.sqrt(mean_squared_error(y_test_actual, y_test_predictions))
mae = mean_absolute_error(y_test_actual, y_test_predictions)
r2 = r2_score(y_test_actual, y_test_predictions)

print("RMSE:", rmse)
print("MAE:", mae)
print("R-squared:", r2)

"""## Step 6: Prediction

**Explanation:**
In this step, we'll use the trained LSTM model to make predictions for future stock prices. This is the core purpose of building the model - to forecast stock prices beyond the training and testing data.

1. **Prepare Input Data:** Create a sequence of historical data for the time period you want to make predictions for. This sequence should have the same format and scaling as the training data.

2. **Make Predictions:** Use the trained model to predict future stock prices based on the prepared input data.

"""

# Calculate the number of days to display (actual and predicted)
num_display_days = 15  # Display 15 days of actual data along with 15 days of predicted data

# Get the last 'num_display_days' days of actual data and dates
last_actual_prices = list(test_data['Close'][-num_display_days:])
last_actual_dates = list(test_data.index[-num_display_days:])

# Prepare input data for future predictions (e.g., next 15 days)
input_data_for_prediction = list(test_data['Close'])

"""### Function to predict future prices with scaling"""

def predict_future_prices(model, input_data, sequence_length, num_predictions, scaler):
    predictions = []
    for _ in range(num_predictions):
        input_sequence = input_data[-sequence_length:]
        input_sequence_scaled = scaler.transform(np.array(input_sequence).reshape(-1, 1))
        input_sequence_scaled = input_sequence_scaled.reshape(1, sequence_length, 1)
        predicted_price_scaled = model.predict(input_sequence_scaled)
        predicted_price = scaler.inverse_transform(predicted_price_scaled)
        input_data.append(predicted_price[0][0])
        predictions.append(predicted_price[0][0])
    return predictions

"""Predicting the Stock Prices of next **15** days"""

# Predict the next 15 days of prices
num_predictions = 15  # Change to 15 days for prediction
predicted_prices = predict_future_prices(model, input_data_for_prediction, sequence_length, num_predictions, scaler_test)

# Calculate the dates for predicted prices (next 'num_display_days' days)
predicted_dates = pd.date_range(start=end_date, periods=num_display_days).tolist()

# Combine actual and predicted data for the chart
days = last_actual_dates + predicted_dates
prices_actual = last_actual_prices + predicted_prices

# Create a single line chart to visualize both actual and predicted prices
plt.figure(figsize=(14,7))
plt.plot(days, prices_actual, linestyle='-', color='b', label='Actual Prices')
plt.plot(days[-num_display_days:], predicted_prices, linestyle='-', color='r', label='Predicted Prices')

# Add labels and title
plt.xlabel('Date')
plt.xticks(rotation = 90)
plt.ylabel('Stock Price')
plt.title('Actual vs. Predicted Stock Prices')

# Show a legend
plt.legend()

# Display the chart
plt.show()